{"version":3,"sources":["ng://ng-inactivity-timer/lib/activity-monitor.token.ts","ng://ng-inactivity-timer/lib/inactivity-config.token.ts","ng://ng-inactivity-timer/lib/inactivity-timer.service.ts"],"names":["ACTIVITY_MONITOR","InjectionToken","INACTIVITY_CONFIG","InactivityTimerService","config","monitor","_this","this","monitor$","BehaviorSubject","artificialActivity$","Subject","timeout$","pipe","filter","x","switchMap","m","merge","getMonitor","throttle","observableInterval","startWith","undefined","map","d","Date","setMinutes","getMinutes","inactivityTime","takeUntil","prototype","getTimeOut","date","timer","f","of","showWarning","warningTime","getTime","timedOut","timeLeft","startMonitor","activate","next","stopMonitor","Injectable","args","providedIn","deps","Inject","Optional","type"],"mappings":"kXAGA,IAAaA,EAAmB,IAAIC,EAAAA,eAClC,oBCDWC,EAAoB,IAAID,EAAAA,eACnC,4BCJFE,EAAA,WAgCE,SAAAA,EACqCC,EAG3BC,GAJV,IAAAC,EAAAC,KACqCA,KAAAH,OAAAA,EAG3BG,KAAAF,QAAAA,EAPFE,KAAAC,SAAW,IAAIC,EAAAA,iBAAyB,GACxCF,KAAAG,oBAAsB,IAAIC,EAAAA,QAShCJ,KAAKK,SAAWL,KAAKC,SAASK,KAC5BC,EAAAA,OAAO,SAAAC,GAAK,QAAEA,IACdC,EAAAA,UAAU,SAAAC,GACR,OAAOC,EAAAA,MAAMZ,EAAKD,QAAQc,aAAcb,EAAKI,qBAAqBG,KAChEO,EAAAA,SAAS,WAAM,OAAAC,EAAAA,SAAmB,OAClCC,EAAAA,UAAUC,WACVC,EAAAA,IAAI,eACIC,EAAI,IAAIC,KAEd,OADAD,EAAEE,WAAWF,EAAEG,aAAexB,EAAOyB,gBAC9BJ,IAETK,EAAAA,UAAUxB,EAAKE,SAASK,KAAKC,EAAAA,OAAO,SAAAC,GAAK,OAACA,iBAU3CZ,EAAA4B,UAAAC,WAAP,WAAA,IAAA1B,EAAAC,KACE,OAAOA,KAAKK,SAASC,KACnBG,EAAAA,UAAU,SAACiB,GACT,OAAOC,EAAAA,MAAM,EAAG,KAAOrB,KACrBG,EAAAA,UAAU,eACFmB,EAAI,IAAIT,KACd,OAAOU,EAAAA,GAAG,CACRC,cAAa/B,EAAKF,OAAOkC,aACrBH,EAAEI,UAAYjC,EAAKF,OAAOkC,YAAcL,EAAKM,UAEjDC,SAAUL,EAAEI,UAAYN,EAAKM,UAC7BE,SAAUR,EAAKM,UAAYJ,EAAEI,mBAalCpC,EAAA4B,UAAAW,aAAP,SAAoBC,QAAA,IAAAA,IAAAA,GAAA,GAClBpC,KAAKC,SAASoC,MAAK,GACfD,GACFpC,KAAKoC,YAQFxC,EAAA4B,UAAAc,YAAP,WACEtC,KAAKC,SAASoC,MAAK,IAOdzC,EAAA4B,UAAAY,SAAP,WACEpC,KAAKG,oBAAoBkC,KAAKrB,gCAjFjCuB,EAAAA,WAAUC,KAAA,CAAC,CACVC,WAAY,OACZC,KAAM,CAAC/C,EAAmBF,4EAQvBkD,EAAAA,OAAMH,KAAA,CAAC7C,wCACPiD,EAAAA,UAAQ,CAAAC,KACRF,EAAAA,OAAMH,KAAA,CAAC/C,wIAnCZ","sourcesContent":["import { InjectionToken } from '@angular/core';\nimport { ActivityMonitor } from './activity-monitor.interface';\n\nexport const ACTIVITY_MONITOR = new InjectionToken<ActivityMonitor>(\n  'Activity Monitor'\n);\n","import { InjectionToken } from '@angular/core';\nimport { InactivityConfig } from './inactivity-config.interface';\n\nexport const INACTIVITY_CONFIG = new InjectionToken<InactivityConfig>(\n  'Inactivity Configuration'\n);\n","import {\n  interval as observableInterval,\n  BehaviorSubject,\n  Observable,\n  Subject,\n  of,\n  timer,\n  merge\n} from 'rxjs';\nimport { ActivityMonitor } from './activity-monitor.interface';\nimport { ACTIVITY_MONITOR } from './activity-monitor.token';\nimport { InactivityConfig } from './inactivity-config.interface';\nimport { INACTIVITY_CONFIG } from './inactivity-config.token';\nimport { Inject, Injectable, Optional } from '@angular/core';\nimport {\n  switchMap,\n  throttle,\n  map,\n  startWith,\n  filter,\n  takeUntil\n} from 'rxjs/operators';\n\n@Injectable({\n  providedIn: 'root',\n  deps: [INACTIVITY_CONFIG, ACTIVITY_MONITOR]\n})\nexport class InactivityTimerService {\n  private timeout$: Observable<Date | never>;\n  private monitor$ = new BehaviorSubject<boolean>(true);\n  private artificialActivity$ = new Subject<void>();\n\n  constructor(\n    @Inject(INACTIVITY_CONFIG) private config: InactivityConfig,\n    @Optional()\n    @Inject(ACTIVITY_MONITOR)\n    private monitor: ActivityMonitor\n  ) {\n    // Merge all monitors together, and activate them via register()\n    this.timeout$ = this.monitor$.pipe(\n      filter(x => !!x),\n      switchMap(m => {\n        return merge(this.monitor.getMonitor(), this.artificialActivity$).pipe(\n          throttle(() => observableInterval(500)), // Throttle - to stop spamming\n          startWith(undefined), // Trigger observable immediately\n          map(() => {\n            const d = new Date();\n            d.setMinutes(d.getMinutes() + config.inactivityTime);\n            return d;\n          }),\n          takeUntil(this.monitor$.pipe(filter(x => !x)))\n        );\n      })\n    );\n  }\n\n  /**\n   * Emits Timeout objects describing current timeout state\n   * @returns Observable<Timeout>\n   */\n  public getTimeOut(): Observable<Timeout> {\n    return this.timeout$.pipe(\n      switchMap((date: Date) => {\n        return timer(0, 60000).pipe(\n          switchMap(() => {\n            const f = new Date();\n            return of({\n              showWarning: this.config.warningTime\n                ? f.getTime() + this.config.warningTime > date.getTime()\n                : false,\n              timedOut: f.getTime() > date.getTime(),\n              timeLeft: date.getTime() - f.getTime()\n            });\n          })\n        );\n      })\n    );\n  }\n\n  /**\n   * Starts listening for activity.\n   * @param activate=false. If true will reset the activity timer as any other activity.\n   * @returns void\n   */\n  public startMonitor(activate = false): void {\n    this.monitor$.next(true);\n    if (activate) {\n      this.activate();\n    }\n  }\n\n  /**\n   * Stops listening for activity.\n   * @returns void\n   */\n  public stopMonitor(): void {\n    this.monitor$.next(false);\n  }\n\n  /**\n   * Provides a programmatic way of simulating activity.\n   * Will reset the activity timer as any other activity.\n   */\n  public activate(): void {\n    this.artificialActivity$.next(undefined);\n  }\n}\n\nexport interface Timeout {\n  showWarning: boolean;\n  timedOut: boolean;\n  timeLeft: number;\n}\n"]}